package com.farmaciadey.data.repository

import com.farmaciadey.data.api.ApiClient
import com.farmaciadey.data.models.ItemCarrito
import com.farmaciadey.data.models.Producto
import com.farmaciadey.data.models.requests.CarritoRequest
import com.farmaciadey.utils.PreferencesManager
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow

class CarritoRepository {
    
    private val carritoService = ApiClient.carritoService
    private lateinit var preferencesManager: PreferencesManager
    
    private val _items = MutableStateFlow<List<ItemCarrito>>(emptyList())
    val items: StateFlow<List<ItemCarrito>> = _items.asStateFlow()
    
    private val _total = MutableStateFlow(0.0)
    val total: StateFlow<Double> = _total.asStateFlow()
    
    fun init(preferencesManager: PreferencesManager) {
        this.preferencesManager = preferencesManager
    }
    
    suspend fun agregarProducto(producto: Producto, cantidad: Int = 1) {
        try {
            val usuarioId = preferencesManager.getUserId()
            if (usuarioId != null) {
                val request = CarritoRequest(
                    usuarioId = usuarioId,
                    productoId = producto.id,
                    cantidad = cantidad
                )
                
                val response = carritoService.agregarAlCarrito(request)
                if (response.isSuccessful) {
                    // Actualizar carrito local
                    agregarProductoLocal(producto, cantidad)
                } else {
                    throw Exception("Error al agregar producto al carrito")
                }
            } else {
                throw Exception("Usuario no autenticado")
            }
        } catch (e: Exception) {
            throw e
        }
    }
    
    private fun agregarProductoLocal(producto: Producto, cantidad: Int = 1) {
        val currentItems = _items.value.toMutableList()
        val existingItemIndex = currentItems.indexOfFirst { it.producto.id == producto.id }
        
        if (existingItemIndex != -1) {
            // Producto ya existe, actualizar cantidad
            val existingItem = currentItems[existingItemIndex]
            currentItems[existingItemIndex] = existingItem.copy(cantidad = existingItem.cantidad + cantidad)
        } else {
            // Nuevo producto (sin ID del carrito porque es local)
            currentItems.add(ItemCarrito(id = null, producto = producto, cantidad = cantidad))
        }
        
        _items.value = currentItems
        actualizarTotal()
    }
    
    suspend fun cargarCarrito() {
        try {
            val usuarioId = preferencesManager.getUserId()
            println("DEBUG: Loading cart for user ID: $usuarioId")
            
            if (usuarioId != null) {
                val response = carritoService.getCarritoUsuario(usuarioId)
                println("DEBUG: Response code: ${response.code()}")
                println("DEBUG: Response success: ${response.isSuccessful}")
                
                if (response.isSuccessful && response.body() != null) {
                    val dataResponse = response.body()!!
                    println("DEBUG: Response body: $dataResponse")
                    
                    if (dataResponse.estado == 1) {
                        val carritoItems = dataResponse.dato?.map { carritoResponse ->
                            println("DEBUG: Processing cart item: ${carritoResponse.id} - ${carritoResponse.producto.nombre}")
                            ItemCarrito(
                                id = carritoResponse.id,
                                producto = carritoResponse.producto, 
                                cantidad = carritoResponse.cantidad
                            )
                        } ?: emptyList()
                        
                        println("DEBUG: Converted ${carritoItems.size} cart items")
                        println("DEBUG: Setting items to StateFlow")
                        _items.value = carritoItems
                        actualizarTotal()
                        println("DEBUG: Cart loading completed successfully")
                    } else {
                        println("DEBUG: Response estado is not 1: ${dataResponse.estado}")
                    }
                } else {
                    println("DEBUG: Response error: ${response.errorBody()?.string()}")
                }
            } else {
                println("DEBUG: User ID is null")
            }
        } catch (e: Exception) {
            println("DEBUG: Exception in cargarCarrito: ${e.message}")
            println("DEBUG: Exception stacktrace: ${e.stackTrace.contentToString()}")
            throw e
        }
    }
    
    suspend fun quitarProducto(productoId: Int) {
        try {
            val usuarioId = preferencesManager.getUserId()
            if (usuarioId != null) {
                // Encontrar el item del carrito con el productoId
                val itemCarrito = _items.value.find { it.producto.id == productoId }
                if (itemCarrito?.id != null) {
                    // Eliminar del backend usando el ID del carrito
                    val response = carritoService.eliminarDelCarrito(itemCarrito.id)
                    if (response.isSuccessful) {
                        // Solo eliminar localmente si la eliminación del backend fue exitosa
                        quitarProductoLocal(productoId)
                        println("DEBUG: Product removed from cart successfully")
                    } else {
                        println("DEBUG: Failed to remove product from backend: ${response.errorBody()?.string()}")
                        throw Exception("Error al eliminar producto del carrito")
                    }
                } else {
                    // Si no tiene ID, solo eliminar localmente (producto agregado localmente que no se sincronizó)
                    quitarProductoLocal(productoId)
                }
            }
        } catch (e: Exception) {
            println("DEBUG: Exception in quitarProducto: ${e.message}")
            throw e
        }
    }
    
    private fun quitarProductoLocal(productoId: Int) {
        val currentItems = _items.value.toMutableList()
        currentItems.removeAll { it.producto.id == productoId }
        _items.value = currentItems
        actualizarTotal()
    }
    
    suspend fun actualizarCantidad(productoId: Int, nuevaCantidad: Int) {
        if (nuevaCantidad <= 0) {
            quitarProducto(productoId)
            return
        }
        
        try {
            val usuarioId = preferencesManager.getUserId()
            if (usuarioId != null) {
                // Aquí deberíamos llamar a un endpoint para actualizar cantidad en el backend
                // Por ahora solo actualizamos localmente
                actualizarCantidadLocal(productoId, nuevaCantidad)
            }
        } catch (e: Exception) {
            throw e
        }
    }
    
    private fun actualizarCantidadLocal(productoId: Int, nuevaCantidad: Int) {
        val currentItems = _items.value.toMutableList()
        val itemIndex = currentItems.indexOfFirst { it.producto.id == productoId }
        
        if (itemIndex != -1) {
            val currentItem = currentItems[itemIndex]
            currentItems[itemIndex] = currentItem.copy(cantidad = nuevaCantidad)
            _items.value = currentItems
            actualizarTotal()
        }
    }
    
    fun limpiarCarrito() {
        _items.value = emptyList()
        _total.value = 0.0
    }
    
    fun getCantidadItems(): Int {
        return _items.value.sumOf { it.cantidad }
    }
    
    private fun actualizarTotal() {
        _total.value = _items.value.sumOf { it.subtotal }
    }
}